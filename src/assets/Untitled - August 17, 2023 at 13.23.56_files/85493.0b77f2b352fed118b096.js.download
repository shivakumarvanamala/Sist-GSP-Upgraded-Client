"use strict";(this.webpackChunk_hz_project_x=this.webpackChunk_hz_project_x||[]).push([[85493],{492314:(e,t,s)=>{s.d(t,{s:()=>f});var o=s(610656),a=s(253624),r=s(647435),i=s(789254),n=s(402820),c=s(863869),d=s(675376),h=s(204094),p=s(535606),u=s(191332),m=s(965041),l=s(650278),y=s(863326),g=s(351931),_=s(624451);class f{constructor(e,t,p,f,w,S){if(this._host=e,this._sessionId=t,this._getAuthToken=p,this._config=f,this._documentLinksCacheResolver=w,this._regionOverride=S,this._generateRetry=async(e,...t)=>{try{return await(0,_.X)(e,y.LU.getDefaultRetryOptions())(...t)}catch(e){return{httpStatus:e.httpStatus,error:e}}},this._newDocument=async(e,t)=>{let s;if(performance.mark("document-service-create-start"),e.docSpec.mimetype=this._config.mimeType,e.docModel){if("string"!=typeof e.docModel)throw new a.R("InvalidDocModel","Expected doc model to be string");s=new Blob([e.docModel]).size;s>10485760&&(e.docModel=await this._uploadDocModelToTempFolderWithRetry(e.docModel,s))}const o=await this._getDocumentRequestUrl(c.bX.Create,{}),r=await this._makeStandardHeaders(!0);t&&(r["x-request-id"]=t);const n=await this._host.fetch(o,{method:"POST",headers:{...r,"Content-Type":"application/json"},body:JSON.stringify(e)});performance.mark("document-service-create-end"),performance.measure("document-service-create","document-service-create-start","document-service-create-end");const d=performance.getEntriesByName("document-service-create");return i.Yd.info("Time taken to create document at DAS",{duration:d&&d[0]?.duration,requestType:e.requestType,docModelSize:s,respondWith:e.respondWith,directorySpec:Boolean(e.directorySpec)}),this.processServerResponse(n)},this._uploadDocModelToTempFolderWithRetry=async(e,t)=>{try{const s=i.Yd.singleton().createRequestLogger({name:"DocumentService",requestId:(0,n.Z)()});i.Yd.traceflow("DocumentService","Uploading document model to temp cloud storage",{docModelSize:t});const o=(0,g.Mu)({logger:s}),a=await(0,_.X)(this._uploadDocModelToTempFolder,o)(e,t,s);return i.Yd.traceflow("DocumentService","Document model upload successful"),a}catch(e){throw new a.R("DocModelUploadFailed","Failed to upload document model to cloud storage temp folder",e)}},this._uploadDocModelToTempFolder=async(e,t,s)=>{const o=await this._createElapsedTimer("UploadDocModel"),a=await this._createRepoAPIUtility(o,s),r=new u.RepositoryLinksCache;r.setIndexLinks(a.getIndexLinks());const c=await this._createRepoAPISession(r),d={repositoryId:await a.getDefaultRepoID(),path:await a.getDefaultRootDirectory()},h=`temp/${(0,n.Z)()}.json`,p=o.subTimer("CreateAsset"),m=await c.createAsset(d,h,!1,"application/json");p.end();const l=o.subTimer("UpdatePrimaryResource"),y=await c.updatePrimaryResource(m.result,e,"application/json",t);l.end(),o.end(),i.Yd.info("DocumentService - upload doc model to user temp storage timing",o.getTimers());const g=y.asset;return{[u.Properties.REPO_REPOSITORY_ID]:g.repositoryId,[u.Properties.REPO_ASSET_ID]:g.assetId}},this._createElapsedTimer=async e=>{const{ElapsedTimer:t}=await s.e(38230).then(s.bind(s,320713));return t.factory(e,this._host)},this._createRepoAPIUtility=async(e,t)=>{const{RepoAPIUtility:o}=await Promise.all([s.e(82375),s.e(29428)]).then(s.bind(s,282375));return o.factory(this._host,this._config.dcxStorageEndpoint,this._config.apiKey,(0,n.Z)(),await this._getAuthToken(),t,e)},this._createRepoAPISession=async e=>{const t=await this._getAuthToken(),s=(0,l.createHTTPService)();return s.setApiKey(this._config.apiKey),s.setAuthToken(t),(0,m.createRepoAPISession)(s,this._config.dcxStorageEndpoint,e)},this._openDocument=async(e,t)=>{performance.mark("document-service-open-start");const s={docId:e,version:t},o=await this._getDocumentRequestUrl(c.bX.GetDocument,s,function(e){if(e)switch(e){case"US":return c.by.US;case"EU":return c.by.EU;case"AP":return c.by.AP}}(this._regionOverride)),a=await this._makeStandardHeaders(!0),r=await this._host.fetch(o,{headers:{...a,Accept:`${this._config.mimeType}`}}),n=await this.processServerResponse(r);performance.mark("document-service-open-end"),performance.measure("document-service-open","document-service-open-start","document-service-open-end");const d=performance.getEntriesByName("document-service-open");return i.Yd.info("Time taken to fetch docmodel & manifest from DAS",{duration:d&&d[0]?.duration}),n},this._getDocumentMetadata=async e=>{const t={docId:e},s=await this._getDocumentRequestUrl(c.bX.GetDocumentMetadata,t),o=await this._makeStandardHeaders(!0),a=await this._host.fetch(s,{headers:{...o,Accept:`${this._config.mimeType}`}});return this.processServerResponse(a)},this._getAppMetadata=async e=>{const t=await this._documentLinksCacheResolver(),s=await t.getMetadataLinks(e);if(!s)throw new a.R("FetchAppMetadata","Unable to get metadata links for document",{logMetadata:{docId:e}});const o=d.HN(s,"http://ns.adobe.com/adobecloud/rel/metadata/application");if(!o)throw new a.R("FetchAppMetadata","Unable to get metadata links for app metadata on document",{logMetadata:{docId:e}});const i=await this._makeStandardHeaders(!1),n=await this._host.fetch(o,{headers:i});if(y.LU.isErrorStatus(n.status)){const e="Error returned from server while fetching app metadata";throw r.o.fromResponse(n,void 0,e,{logMetadata:{url:o,sessionId:this._sessionId,host:location.origin}})}const c=await n.json();return{httpStatus:n.status,payload:c}},this._copyDocumentAtVersion=async e=>{const{docId:t,docName:s,version:o}=e,i=await this._getDocumentRequestUrl(c.bX.Create,{}),n={docSpec:{mimetype:this._config.mimeType},sourceDocSpec:{[u.Properties.REPO_ASSET_ID]:t,[u.Properties.REPO_NAME]:s,[u.Properties.REPO_VERSION]:o}},d=await this._makeStandardHeaders(!0),h=await this._host.fetch(i,{method:"POST",headers:{...d,"Content-Type":"application/json"},body:JSON.stringify(n)});if(y.LU.isErrorStatus(h.status))throw r.o.fromResponse(h,void 0,"[copyDocumentAtVersion] error status returned from server",{logMetadata:{documentCreationSpec:n,url:i,sessionId:this._sessionId,host:location.origin}});const p=h.headers.get("Location");if(!p)throw new a.R("DocumentVersionRecovery","Missing Location header for Create Document Using Version Recovery API request",{logMetadata:{requestId:h.headers.get("x-request-id"),url:i,sessionId:this._sessionId,host:location.origin}});return p},this._uploadAssets=async(e,t,s)=>{e.docSpec.mimetype||(e.docSpec.mimetype=this._config.mimeType);const o={disableLESDelta:s},a=await this._getDocumentRequestUrl(c.bX.Asset,o),r={...await this._makeStandardHeaders(!0),"Content-Type":"application/json"};t&&(r.prefer="respond-async");const i=await this._host.fetch(a,{method:"POST",headers:r,body:JSON.stringify(e)});if(y.LU.isErrorStatus(i.status)){const e=await this.processResponseError(i);throw e.message=`uploadAssets: Error uploading assets: ${e.message} ${i.status}`,e}const n=200===i.status?await i.json():void 0;return{httpStatus:i.status,payload:n}},this._getDirectoryAsset=async e=>{const t=await this._documentLinksCacheResolver(),s=await t.getMetadataLinks(e);if(!s)throw new a.R("GetDirectoryAsset","Unable to get metadata links for document",{logMetadata:{assetId:e}});const i=d.HN(s,"http://ns.adobe.com/adobecloud/rel/directory");if(!i)throw new a.R("GetDirectoryAsset","Missing metadata links for page API request for document",{logMetadata:{assetId:e}});const n=new o.Z(i).expand({}),c=await this._makeStandardHeaders(!1),h=await this._host.fetch(n,{method:"HEAD",headers:c});if(y.LU.isErrorStatus(h.status))throw r.o.fromResponse(h,"GetDirectoryAsset","[getDirectoryAsset] error status returned from server",{logMetadata:{assetId:e,fetchUrl:n,sessionId:this._sessionId,host:location.origin}});return{assetId:h.headers.get("asset-id"),repositoryId:h.headers.get("repository-id")}},!this._apiURLs){const e={dasURL:this._config.apiHost,[c.by.US]:this._config.USDasUrl||this._config.apiHost,[c.by.EU]:this._config.EUDasUrl||this._config.apiHost,[c.by.AP]:this._config.APDasUrl||this._config.apiHost};this._apiURLs=(0,h.P)(e)}}async _getDocumentRequestUrl(e,t,s){const a=this._apiURLs;let r;r=s?a[s]._links:a._links;const i=Object(r)[e].href;return new o.Z(i).expand(t)}async _makeStandardHeaders(e){const t=await this._getAuthToken(),s=y.LU.makeStandardHeaders(t,this._config.apiKey);return e&&(s["x-session-id"]=this._sessionId),s}async newDocument(e,t){return await this._generateRetry(this._newDocument,e,t)}async openDocument(e,t){return await this._generateRetry(this._openDocument,e,t)}async getDocumentMetadata(e){return await this._generateRetry(this._getDocumentMetadata,e)}async getAppMetadata(e){try{return await(0,_.X)(this._getAppMetadata,y.LU.getDefaultRetryOptions())(e)}catch(e){return{httpStatus:e?.httpStatus,error:e}}}async listDocumentVersions(e){const{docId:t,limit:s,start:a}=e,i={limit:s,orderBy:"-created",resource:"version-history",start:a},n=await this._documentLinksCacheResolver(),c=await n.getMetadataLinks(t);let h;if(c&&(h=d.HN(c,"http://ns.adobe.com/adobecloud/rel/page")),!h)throw new Error("Missing index links for page API request");const p=new o.Z(h).expand(i),u=await this._makeStandardHeaders(!1),m=await this._host.fetch(p,{headers:{...u,"Content-Type":"application/vnd.adobe.versions+json"}});if(y.LU.isErrorStatus(m.status))throw r.o.fromResponse(m,void 0,"[listDocumentVersions] error status returned from server",{logMetadata:{docId:t,limit:s,start:a,fetchUrl:p,sessionId:this._sessionId,host:location.origin}});return m.json()}async copyDocumentAtVersion(e){return await(0,_.X)(this._copyDocumentAtVersion,y.LU.getDefaultRetryOptions())(e)}async processServerResponse(e){if(y.LU.isErrorStatus(e.status))throw await this.processResponseError(e);const t={httpStatus:e.status};201===e.status&&(e.headers.get("location")&&(t.location=e.headers.get("location")),e.headers.get("x-document-id")&&(t.documentId=e.headers.get("x-document-id")));try{const s=await e.json();(await this._documentLinksCacheResolver()).cacheLinksFromResponse(s),t.payload=s}catch(e){i.Yd.warn("Could not parse json from body",e)}return t}async processResponseError(e){let t;try{const s=await e.json();t=r.o.fromResponse(e,s.errorCode,s.message,{logMetadata:{url:e.url,sessionId:this._sessionId,host:location.origin}})}catch(s){t=new r.o(e.status)}return i.Yd.warn("DocumentService: processing error returned from server",t),t}async renameDocument(e,t,s,o,a){const i=await this._documentLinksCacheResolver(),n=await i.getIndexLinks(e);let c;if(n&&(c=d.HN(n,"http://ns.adobe.com/adobecloud/rel/ops")),!c)throw new Error("Missing index links for ops API request");const{newDocName:h}=t;if(h.match(/[\\/*]/))throw new Error("newDocName cannot contain slashes or wildcards");let u=`${o.substring(0,o.lastIndexOf("/")+1)}${h}`;const m=p.M[a];u.endsWith(m)||(u+=m);const l={op:"move",target:{"repo:path":u,"repo:repositoryId":s},source:{"repo:path":o,"repo:repositoryId":s}},g=await this._makeStandardHeaders(!1),_=await this._host.fetch(c,{method:"POST",headers:{...g,"Content-Type":"application/vnd.adobe.asset-operation+json"},body:JSON.stringify(l)}),f=await _.json();if(y.LU.isErrorStatus(_.status)){const e=`error status returned from server: ${_.status}`;throw r.o.fromResponse(_,void 0,e,{logMetadata:{url:c,sessionId:this._sessionId,host:location.origin}})}if(f&&f.error){const e=`payload error returned from server: ${f.error.title}`;throw new r.o(f.error.status,e,void 0,{logMetadata:{url:c,sessionId:this._sessionId,host:location.origin}})}return f}async uploadAssets(e,t=!0,s){try{return await(0,_.X)(this._uploadAssets,y.LU.getDefaultRetryOptions())(e,t,s)}catch(e){return{httpStatus:e.httpStatus,error:e}}}async getDirectoryAsset(e){return await(0,_.X)(this._getDirectoryAsset,y.LU.getDefaultRetryOptions())(e)}}},685493:(e,t,s)=>{s.d(t,{EG:()=>a});var o=s(492314);const a={create:(e,t,s,a,r,i)=>new o.s(e,t,s,a,r,i)}},204094:(e,t,s)=>{s.d(t,{P:()=>r});var o=s(863869);const a=e=>({_links:{[o.bX.Create]:{href:`${e}/documents/`,templated:!1,type:"application/json"},[o.bX.GetDocument]:{href:`${e}/documents/{docId}{?version}`,templated:!0,type:"application/json"},[o.bX.GetDocumentMetadata]:{href:`${e}/documents/{docId}/metadata`,templated:!0,type:"application/json"},[o.bX.GetDocumentWithRepositoryId]:{href:`${e}/repositories/{repoId}/documents/{docId}`,templated:!0,type:"application/json"},[o.bX.GetDocumentMetadataWithRepositoryId]:{href:`${e}/repositories/{repoId}/documents/{docId}/metadata`,templated:!0,type:"application/json"},[o.bX.Asset]:{href:`${e}/assets/{?disableLESDelta}`,templated:!0,type:"application/json"}}}),r=e=>Object.assign({[o.by.US]:a(e[o.by.US]),[o.by.EU]:a(e[o.by.EU]),[o.by.AP]:a(e[o.by.AP])},a(e.dasURL))}}]);
//# sourceMappingURL=85493.0b77f2b352fed118b096.js.map